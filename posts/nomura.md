---
title: '野村プログラミングコンテスト C Folia'
date: '2020-05-30'
category: "problems"
---

## C Folia

[問題](https://atcoder.jp/contests/nomura2020/tasks/nomura2020_c)

二分木において、各深さの葉の数が与えられる。
条件を満たす、ノードの最大の数を求めよ。

## 考察
高度な貪欲典型問題。
難しいのは、上界となる条件が二種類あるところ

- 二分木なので、深さiにおいて2**i以上にはならない
- 葉を作ってしまうと、そこから2倍にはできない

この２つを上手く数式に表す必要があるが、添字が合わなかったりして破滅。
こういう問題は数式をきちんと考えたほうが良いのかな。うーん。


## 解
深さiのノードの数をp[i]、葉の数(条件)をa[i]とする

### 解1. 上から見る方法
深さi+1のノードの数は、下記のうち小さい方で与えられる

1. 前のノードで、葉にならなかったものの2倍 `2*(p[i]-a[i])`
1. それより深いに葉になるノードの和 `sum(a[i+1:])`

2番目が肝で、**いずれは葉になる**ので、その値を超えてはいけない。

これを上から求めていくと、答えになる。
深さ0のときとか、場合分けは丁寧に。

[回答](https://atcoder.jp/contests/nomura2020/submissions/13759299)

### 解2. 下から見る方法

最後からさかのぼっていく。
深さiにおけるp[i]の値は

- 最大値
    - `2^i` (二分木でずっと進んできた場合)
    - `p[i+1]-a[i+1]+a[i]` #その深さの葉とノードの和 
- 最小値 : 
    - ceil(p[i+1]/2) + a[i]

を計算結果として持っておく。

次に、上から下っていく。深さiにおいて条件を満たしつつ、最大となるノードの数q[i]は以下の最小値

- `2*(q[i-1]-a[i-1])` #使えるノード値の二倍
- `2^i` #二分木でずっと進んできた場合 
- `q[i]` #下から順番に見てきたときの上界

q[i]の和が求める答え

> 注意としては、`2^i`がバカでかくなる。故に普通にやるとpythonではTLEを起こす。AsとNの制約から、葉の数は多くても`max(A_i)*N<=10^13`以下くらいにできるから、それより大きい2冪を用意しなくて良いとかそういう感じな気がする(関係なく通せるpypyつよい)。これでpythonでもAC

[回答](https://atcoder.jp/contests/nomura2020/submissions/13760635)

## 感想

- 二分木の性質をうまく使った良い問題だなぁ。高度貪欲は典型に落とし込めないので、難しいな。
- 数式にして丁寧にやると、そこまで難しくなかった気がするが、それをサボってアドホックに行こうとしたのが失敗。
- 上界の条件が複数あるので、丁寧に拾っていくことがポイント。上からか下からかは正直どちらでも良い。