---
title: 'AGC044'
date: '2020-05-24'
category: "problems"
---

## A. Pay to Win
### 考察
`2^a*3^b*5^c`くらいしか計算かからないだろうと思っていたが、+1, -1にかかるコストが厄介だなぁと。
+1 -1 をどのタイミングで入れるか？とか考えるのかなと思っていたがよくわからず破滅

### 解
大きい方から減らしていく。(逆操作)。逆操作は割と考察の典型なのでできるようにしておきたいところ。
ある数Xにおいて、nにするためには

X%n == 0 になるように足す or 引く
をする。

193 の場合、5で割りたいなら、-3 or +2 をする。という具合。
これを+7する必要はなく、それならば+2⇨÷5⇨+1のほうがトータルでコストは低いのは明らか。
つまり、ある数nで割りたいときに、次の状態はfloor(X/n)とceil(X/n)の二種類が考えられる。

しかし、これにかかる計算量がどうなるかがあんまりわかっていない。
直感的に、`N/(2^a*3^b*5^c)`のfloorとceilで表現できるくらいの数になりそうだなぁと言うのがわかるらしいが、ほんまか？あまりしっくり来ていない。

イメージ的には、`f(n) = f(ceil(n/5)) + D*n%5+C `みたいな再起関数を書いていく。計算量削減のために、メモ化しておくこともポイント。

f(n) = min(f(floor(n/2)+amari*D+A, ....,))

いや、普通に難しくない？再起が苦手なだけか。
⇒ AC　[コード](https://atcoder.jp/contests/agc044/submissions/13564996)


## B. Joker
### 考察
初め、一直線にしか進めないと思っていて、それなら2次元方向にBITなどをもたせて最小値を足し上げるで行けるかなと思ったが、破滅。
よく呼んでみると、自由に動けることが判明した。難しい。

その後、席を立った人の影響をどうやってもたせるか考えていた。
まず全マスに対して、初期状態でコストどのくらいで出られるか(`fields`)を持っておき、そこからうまく`fields`をいじって行くことを考える。

愚直にはBFSをして、席を立つ毎に影響範囲をカバーか？と思ったが、そもそもO(N^4)になりそうで破滅だろと思ってやめる。
席を立ったときに、影響範囲をunionfindでつないでうまくいかないかと考えたり、色々したがサンプル合わず。

### 解
実はBFSがO(N^4)というのが間違っていて、初期状態の`fields`で、距離の和が出せる。それを足しても高々O(N^3)なので、一回の操作で最低1は減り、全て0になったらおしまいということを考えると、O(N^3)の操作回数でカタがつくお話。

BFSがどのように作用して行くかを考えるというのがポイントだったようで、この考察はかなり難しいなぁ。というところだった。

pythonの場合はここから計算量を落とさないと行けなくて、それも結構厳しかった。2次元配列のほうがわかりやすいのだけれど、それじゃアクセスに時間がかかって間に合わないので色々と工夫しながらやった

以下やったこと。(配列アクセスを減らしていく方針)

- 毎回の操作で-1などにするところは、内包表記にする
- 二次元のところは1次元化。(0,1)->+n (1,0)->1 という具合
- if文を使わない。埋まっている時+1, 空席の時 0なので、occupied配列は1,0で持たせておく
- あまりと割り算はdivmodという関数が用意されているので、それを使うdivmod(a,n)=>a//n, a%n
- 

⇨ 1999ms AC [コード](https://atcoder.jp/contests/agc044/submissions/13562893)